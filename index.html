<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Calendar • Three.js</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Baloo+2:wght@600&family=Nunito:wght@500;700&display=swap');

      :root {
        font-family: 'Baloo 2', 'Nunito', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: radial-gradient(circle at top, #ffe6c9 0%, #ffc278 45%, #f7974c 100%);
        color: #1b3d91;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background: radial-gradient(circle at top, #ffe6c9 0%, #ffc278 45%, #f7974c 100%);
      }

      #scene-container {
        flex: 1;
        position: relative;
        box-shadow: inset 0 40px 120px rgba(255, 255, 255, 0.45);
      }

      canvas {
        display: block;
      }

      .overlay {
        position: absolute;
        inset: 1rem 1rem auto auto;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        text-align: right;
      }

      .overlay span {
        font-size: 0.95rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #c41230;
        text-shadow: 0 2px 4px rgba(255, 255, 255, 0.6);
      }

      .overlay small {
        font-size: 0.75rem;
        letter-spacing: 0.15em;
        color: rgba(27, 61, 145, 0.75);
      }
    </style>
  </head>
  <body>
    <div id="scene-container">
      <div class="overlay">
        <span id="month-label"></span>
        <small>Drag to rotate · Scroll to zoom</small>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      const container = document.getElementById('scene-container');
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        100
      );
      camera.position.set(22, 16, 32);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(
        'image.png',
        (texture) => {
          texture.colorSpace = THREE.SRGBColorSpace;
          texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
          kittyTexture = texture;
          createCalendar(calendarDate);
        },
        undefined,
        (error) => {
          console.warn('Unable to load hi-def kitty texture:', error);
        }
      );

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(0, 0, 0);
      controls.minDistance = 10;
      controls.maxDistance = 26;
      controls.update();

      const ambient = new THREE.AmbientLight(0xffffff, 0.55);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
      dirLight.position.set(6, 12, 10);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.set(2048, 2048);
      scene.add(dirLight);

      const monthLabel = document.getElementById('month-label');

      const DAYS_PER_WEEK = 7;
      const WEEKS_VISIBLE = 6;
      const CUBE_SIZE = 1.4;
      const GAP = 0.02;
      const palette = {
        baseRed: '#ea2b2f',
        studRed: '#ef383c',
        warmWhite: '#fffaf3',
        ivory: '#fff3df',
        accentBlue: '#1c2c84',
        numberBlue: '#3243c4',
        weekendPink: '#ffe1e8',
        weekdaysRed: '#d92032',
        weekendLabel: '#f06a8b',
        todaySunshine: '#ffe066',
        subtleOutline: '#f5b3c4',
        bowRed: '#ff304a',
        kittyWhite: '#fff7fb',
        kittyNose: '#ffcb6b',
      };

      const WEEKDAY_CUBE_HEIGHT = CUBE_SIZE * 0.45;
      const DAY_HEIGHT = CUBE_SIZE * 0.5;
      const BOTTOM_PANEL_HEIGHT = DAY_HEIGHT * 2;
      const BOTTOM_PANEL_BASE_HEIGHT = CUBE_SIZE * 1.6;

      const eventSpecs = [
        { label: 'Birthday', accent: '#ffb7d5', labelScale: 0.15 },
        { label: 'Travel', accent: '#c4e1ff', labelScale: 0.18 },
      ];
      const iconSpecs = [
        { accent: '#ffdbe8', icon: 'apple' },
        { accent: '#d5e9ff', icon: 'bow' },
      ];

      let calendarDate = new Date();
      let kittyTexture = null;

      const RIG_ELEVATION = CUBE_SIZE * 1.5;
      const calendarRig = new THREE.Group();
      calendarRig.position.y = RIG_ELEVATION;
      scene.add(calendarRig);
      const ground = new THREE.Mesh(
        new THREE.CircleGeometry(26, 64),
        new THREE.MeshStandardMaterial({ color: '#f0ad72', roughness: 1, metalness: 0 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      const calendarGroup = new THREE.Group();
      const weekdayGroup = new THREE.Group();
      const decorGroup = new THREE.Group();
      calendarRig.add(decorGroup);
      calendarRig.add(calendarGroup);
      calendarRig.add(weekdayGroup);

      calendarGroup.position.y = CUBE_SIZE * 0.85;
      weekdayGroup.position.y = CUBE_SIZE * 0.85;

      const DECOR_BASE_DEPTH = CUBE_SIZE * 1.4;
      const TILE_DEPTH = DECOR_BASE_DEPTH * 0.94;
      const baseGeometry = new THREE.BoxGeometry(CUBE_SIZE, DAY_HEIGHT, TILE_DEPTH);
      const WEEKDAY_CUBE_GEOMETRY = new THREE.BoxGeometry(CUBE_SIZE, WEEKDAY_CUBE_HEIGHT, TILE_DEPTH);
      const emptyDayMaterial = new THREE.MeshStandardMaterial({
        color: palette.baseRed,
        roughness: 0.55,
        metalness: 0.1,
      });

      const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      let layoutState = null;

      const NUMBER_X_SCALE = 0.78;
      function padTextureText(ctx, label, size) {
        ctx.save();
        ctx.translate(size / 2, size * 0.6);
        ctx.scale(NUMBER_X_SCALE, 1);
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }

      function createDayTexture({ label, active, highlight, weekend }) {
        const size = 512;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size,
        });
        const ctx = canvas.getContext('2d');

        const showDateNumber = active || highlight;
        const background = highlight
          ? palette.todaySunshine
          : weekend && active
          ? palette.weekendPink
          : showDateNumber
          ? palette.warmWhite
          : palette.baseRed;
        const border = highlight ? '#f9c74f' : showDateNumber ? palette.subtleOutline : palette.baseRed;
        const textColor = highlight ? palette.baseRed : weekend ? palette.weekendLabel : palette.numberBlue;

        ctx.fillStyle = background;
        ctx.strokeStyle = border;
        ctx.lineWidth = size * 0.04;
        ctx.fillRect(0, 0, size, size);
        ctx.strokeRect(
          ctx.lineWidth / 2,
          ctx.lineWidth / 2,
          size - ctx.lineWidth,
          size - ctx.lineWidth
        );

        if (showDateNumber) {
          ctx.fillStyle = textColor;
          const fontSize = size * 0.32;
          ctx.font = `600 ${fontSize}px 'Nunito', 'Baloo 2', sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = 'rgba(0,0,0,0.08)';
          ctx.shadowBlur = size * 0.04;
          padTextureText(ctx, label, size);
          ctx.shadowBlur = 0;
        }

        if (weekend && !highlight) {
          ctx.fillStyle = 'rgba(255, 48, 74, 0.18)';
          ctx.beginPath();
          ctx.arc(size * 0.82, size * 0.2, size * 0.07, 0, Math.PI * 2);
          ctx.fill();
        }

        return new THREE.CanvasTexture(canvas);
      }

      function createWeekdayTexture(label, weekend) {
        const size = 512;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size,
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = weekend ? palette.weekendLabel : palette.weekdaysRed;
        ctx.fillRect(0, 0, size, size);
        ctx.fillStyle = palette.warmWhite;
        ctx.font = `700 ${size * 0.34}px 'Baloo 2', 'Nunito', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0,0,0,0.18)';
        ctx.shadowBlur = size * 0.04;
        ctx.fillText(label, size / 2, size / 2);
        return new THREE.CanvasTexture(canvas);
      }

      function drawApple(ctx, x, y, radius) {
        ctx.fillStyle = '#ff3b30';
        ctx.strokeStyle = '#ce0f1d';
        ctx.lineWidth = radius * 0.25;
        ctx.beginPath();
        ctx.arc(x - radius * 0.3, y, radius, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.3, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(x, y + radius * 0.05, radius * 0.95, radius * 0.9, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#3e9c44';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.2, y - radius * 0.85, radius * 0.4, radius * 0.5, 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(x + radius * 0.2, y - radius * 0.9, radius * 0.3, radius * 0.45, -0.5, 0, Math.PI * 2);
        ctx.fill();
      }

      function createLeftColumnAppleTexture() {
        const size = 512;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size,
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = palette.warmWhite;
        ctx.fillRect(0, 0, size, size);
        drawApple(ctx, size / 2, size / 2, size * 0.3);
        return new THREE.CanvasTexture(canvas);
      }

      function drawBow(ctx, x, y, size) {
        ctx.fillStyle = palette.bowRed;
        ctx.strokeStyle = '#a01120';
        ctx.lineWidth = size * 0.12;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x - size, y - size * 0.4, x - size * 1.1, y + size * 0.5, x - size * 0.2, y + size * 0.1);
        ctx.bezierCurveTo(x - size * 1.1, y + size * 0.6, x - size * 0.3, y + size * 1, x, y + size * 0.3);
        ctx.bezierCurveTo(x + size * 0.3, y + size * 1, x + size * 1.1, y + size * 0.6, x + size * 0.2, y + size * 0.1);
        ctx.bezierCurveTo(x + size * 1.1, y + size * 0.5, x + size, y - size * 0.4, x, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.fillStyle = '#ff7b8c';
        ctx.arc(x, y + size * 0.2, size * 0.35, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawKittyFace(ctx, x, y, size) {
        ctx.fillStyle = palette.kittyWhite;
        ctx.beginPath();
        ctx.ellipse(x, y, size, size * 0.85, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x - size * 0.6, y - size * 0.2);
        ctx.lineTo(x - size * 0.3, y - size * 0.9);
        ctx.lineTo(x - size * 0.05, y - size * 0.2);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + size * 0.6, y - size * 0.2);
        ctx.lineTo(x + size * 0.3, y - size * 0.9);
        ctx.lineTo(x + size * 0.05, y - size * 0.2);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = palette.accentBlue;
        ctx.beginPath();
        ctx.arc(x - size * 0.3, y - size * 0.05, size * 0.12, 0, Math.PI * 2);
        ctx.arc(x + size * 0.3, y - size * 0.05, size * 0.12, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = palette.kittyNose;
        ctx.beginPath();
        ctx.ellipse(x, y + size * 0.05, size * 0.18, size * 0.12, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#d9c7cf';
        ctx.lineWidth = size * 0.06;
        ctx.beginPath();
        ctx.moveTo(x - size * 0.7, y + size * 0.1);
        ctx.lineTo(x - size * 0.35, y + size * 0.05);
        ctx.moveTo(x + size * 0.7, y + size * 0.1);
        ctx.lineTo(x + size * 0.35, y + size * 0.05);
        ctx.stroke();

        drawBow(ctx, x + size * 0.55, y - size * 0.45, size * 0.45);
      }

      function createBottomPanelTexture(heightFactor = 1) {
        const canvas = Object.assign(document.createElement('canvas'), {
          width: 2048,
          height: Math.max(128, Math.round(640 * heightFactor)),
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = palette.baseRed;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawKittyFace(ctx, canvas.width * 0.1, canvas.height * 0.55, canvas.height * 0.35);
        ctx.fillStyle = '#fff';
        ctx.font = `700 ${canvas.height * 0.35}px 'Baloo 2', 'Nunito', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('HELLO CATTY', canvas.width * 0.55, canvas.height * 0.55);
        drawBow(ctx, canvas.width * 0.88, canvas.height * 0.5, canvas.height * 0.22);
        return new THREE.CanvasTexture(canvas);
      }

      function createEventBrickTexture({ label, accent, icon, labelScale = 0.18 }) {
        const size = 512;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size,
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, size, size);
        ctx.strokeStyle = accent;
        ctx.lineWidth = size * 0.1;
        ctx.strokeRect(ctx.lineWidth / 2, ctx.lineWidth / 2, size - ctx.lineWidth, size - ctx.lineWidth);
        const iconCenterX = label ? size * 0.2 : size * 0.5;
        const iconCenterY = label ? size * 0.45 : size * 0.5;
        const iconScale = label ? 0.18 : 0.28;
        if (icon === 'apple') {
          drawApple(ctx, iconCenterX, iconCenterY, size * iconScale);
        } else if (icon === 'bow') {
          drawBow(ctx, iconCenterX, iconCenterY, size * iconScale);
        }
        if (!label) {
          return new THREE.CanvasTexture(canvas);
        }
        ctx.fillStyle = palette.numberBlue;
        ctx.font = `700 ${size * labelScale}px 'Nunito', 'Baloo 2', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label.toUpperCase(), size / 2, size * 0.57);
        return new THREE.CanvasTexture(canvas);
      }

      function createFlipCardTexture(date = new Date()) {
        const size = 1024;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size * 1.2,
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = palette.warmWhite;
        ctx.strokeStyle = '#d9d9d9';
        ctx.lineWidth = size * 0.04;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeRect(
          ctx.lineWidth / 2,
          ctx.lineWidth / 2,
          canvas.width - ctx.lineWidth,
          canvas.height - ctx.lineWidth
        );
        const dayLabel = date.getDate().toString();
        const monthLabel = date
          .toLocaleString('default', { month: 'long' })
          .toUpperCase();
        ctx.fillStyle = palette.numberBlue;
        ctx.font = `700 ${size * 0.7}px 'Baloo 2', 'Nunito', sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(dayLabel, canvas.width / 2, canvas.height * 0.45);
        ctx.fillStyle = palette.accentBlue;
        ctx.font = `600 ${size * 0.18}px 'Nunito', sans-serif`;
        ctx.fillText(monthLabel, canvas.width / 2, canvas.height * 0.78);
        return new THREE.CanvasTexture(canvas);
      }

      function addClassicKitty(kittyGroup) {
        const kittyMaterial = new THREE.MeshStandardMaterial({
          color: palette.kittyWhite,
          roughness: 0.35,
          metalness: 0.05,
        });
        const head = new THREE.Mesh(new THREE.SphereGeometry(CUBE_SIZE * 0.55, 32, 32), kittyMaterial);
        head.scale.y = 0.85;
        head.position.y = CUBE_SIZE * 0.2;
        kittyGroup.add(head);

        const body = new THREE.Mesh(
          new THREE.BoxGeometry(CUBE_SIZE * 0.65, CUBE_SIZE * 0.6, CUBE_SIZE * 0.4),
          new THREE.MeshStandardMaterial({ color: palette.accentBlue, metalness: 0.05, roughness: 0.5 })
        );
        body.position.set(0, -CUBE_SIZE * 0.2, 0);
        kittyGroup.add(body);

        const nose = new THREE.Mesh(
          new THREE.SphereGeometry(CUBE_SIZE * 0.08, 16, 16),
          new THREE.MeshStandardMaterial({ color: palette.kittyNose })
        );
        nose.position.set(0, CUBE_SIZE * 0.25, CUBE_SIZE * 0.45);
        kittyGroup.add(nose);

        const eyeGeometry = new THREE.SphereGeometry(CUBE_SIZE * 0.07, 16, 16);
        const eyeMaterial = new THREE.MeshStandardMaterial({ color: palette.accentBlue, roughness: 0.3 });
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.scale.y = 1.35;
        rightEye.scale.y = 1.35;
        leftEye.position.set(-CUBE_SIZE * 0.23, CUBE_SIZE * 0.28, CUBE_SIZE * 0.48);
        rightEye.position.set(CUBE_SIZE * 0.23, CUBE_SIZE * 0.28, CUBE_SIZE * 0.48);
        kittyGroup.add(leftEye, rightEye);

        const whiskerGeometry = new THREE.BoxGeometry(CUBE_SIZE * 0.42, CUBE_SIZE * 0.02, CUBE_SIZE * 0.02);
        const whiskerMaterial = new THREE.MeshStandardMaterial({ color: '#d7cdd3', roughness: 0.6 });
        for (let i = 0; i < 2; i += 1) {
          const whisker = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
          whisker.position.set(-CUBE_SIZE * 0.42, CUBE_SIZE * (0.18 - i * 0.08), CUBE_SIZE * 0.35);
          whisker.rotation.z = THREE.MathUtils.degToRad(i === 0 ? -5 : 8);
          kittyGroup.add(whisker);
          const mirror = whisker.clone();
          mirror.position.x *= -1;
          mirror.rotation.z *= -1;
          kittyGroup.add(mirror);
        }

        const bow = new THREE.Mesh(
          new THREE.TorusGeometry(CUBE_SIZE * 0.25, CUBE_SIZE * 0.09, 16, 32),
          new THREE.MeshStandardMaterial({ color: palette.bowRed, metalness: 0.2, roughness: 0.35 })
        );
        bow.rotation.y = Math.PI / 2;
        bow.position.set(CUBE_SIZE * 0.35, CUBE_SIZE * 0.55, 0);
        kittyGroup.add(bow);

        const earGeometry = new THREE.ConeGeometry(CUBE_SIZE * 0.18, CUBE_SIZE * 0.3, 16);
        const leftEar = new THREE.Mesh(earGeometry, kittyMaterial);
        const rightEar = new THREE.Mesh(earGeometry, kittyMaterial);
        const tiltBack = THREE.MathUtils.degToRad(-10);
        const yawOutward = THREE.MathUtils.degToRad(8);
        const rollOutward = THREE.MathUtils.degToRad(16);
        leftEar.rotation.set(tiltBack, -yawOutward, -rollOutward);
        rightEar.rotation.set(tiltBack, yawOutward, rollOutward);
        leftEar.position.set(-CUBE_SIZE * 0.32, CUBE_SIZE * 0.63, -CUBE_SIZE * 0.02);
        rightEar.position.set(CUBE_SIZE * 0.32, CUBE_SIZE * 0.63, -CUBE_SIZE * 0.02);
        kittyGroup.add(leftEar, rightEar);
      }

      function addHiDefKitty(kittyGroup) {
        if (!kittyTexture || !kittyTexture.image) {
          addClassicKitty(kittyGroup);
          return;
        }

        const aspect = kittyTexture.image.width
          ? kittyTexture.image.height / kittyTexture.image.width
          : 1;
        const displayWidth = CUBE_SIZE * 2.6;
        const displayHeight = displayWidth * aspect;
        const frameDepth = CUBE_SIZE * 0.15;

        const stand = new THREE.Mesh(
          new THREE.CylinderGeometry(displayWidth * 0.2, displayWidth * 0.26, CUBE_SIZE * 0.6, 32),
          new THREE.MeshStandardMaterial({ color: palette.accentBlue, metalness: 0.3, roughness: 0.35 })
        );
        stand.position.set(0, -displayHeight / 2 - CUBE_SIZE * 0.45, -frameDepth * 0.35);
        kittyGroup.add(stand);

        const accentRing = new THREE.Mesh(
          new THREE.TorusGeometry(displayWidth * 0.32, CUBE_SIZE * 0.05, 24, 48),
          new THREE.MeshStandardMaterial({ color: '#fcd0e0', metalness: 0.12, roughness: 0.3 })
        );
        accentRing.rotation.x = Math.PI / 2;
        accentRing.position.set(0, -displayHeight / 2 - CUBE_SIZE * 0.2, frameDepth * 0.1);
        kittyGroup.add(accentRing);

        const frame = new THREE.Mesh(
          new THREE.BoxGeometry(displayWidth * 1.08, displayHeight * 1.12, frameDepth),
          new THREE.MeshStandardMaterial({ color: palette.warmWhite, metalness: 0.25, roughness: 0.35 })
        );
        frame.position.set(0, 0, -frameDepth * 0.4);
        kittyGroup.add(frame);

        const inset = new THREE.Mesh(
          new THREE.BoxGeometry(displayWidth * 1.02, displayHeight * 1.06, frameDepth * 0.6),
          new THREE.MeshStandardMaterial({ color: '#ffd4e1', metalness: 0.12, roughness: 0.4 })
        );
        inset.position.set(0, 0, -frameDepth * 0.15);
        kittyGroup.add(inset);

        const artPanel = new THREE.Mesh(
          new THREE.PlaneGeometry(displayWidth, displayHeight),
          new THREE.MeshStandardMaterial({
            map: kittyTexture,
            transparent: true,
            side: THREE.DoubleSide,
            roughness: 0.18,
            metalness: 0.05,
          })
        );
        artPanel.position.set(0, 0, frameDepth * 0.35);
        kittyGroup.add(artPanel);

        const acrylic = new THREE.Mesh(
          new THREE.PlaneGeometry(displayWidth, displayHeight),
          new THREE.MeshPhysicalMaterial({
            transparent: true,
            opacity: 0.35,
            roughness: 0.05,
            transmission: 0.65,
            thickness: 0.01,
          })
        );
        acrylic.position.set(0, 0, frameDepth * 0.4);
        kittyGroup.add(acrylic);

        const spotlight = new THREE.SpotLight(0xff9ac5, 0.8, CUBE_SIZE * 6, Math.PI / 6, 0.3);
        spotlight.position.set(0, displayHeight * 0.6, frameDepth * 2);
        spotlight.target.position.set(0, 0, 0);
        kittyGroup.add(spotlight);
        kittyGroup.add(spotlight.target);

        kittyGroup.rotation.y = THREE.MathUtils.degToRad(-6);
      }

      function buildDecor(width, height, date) {
        decorGroup.clear();
        const paddingX = CUBE_SIZE * 0.9;
        const paddingY = CUBE_SIZE * 1.4;
        const baseDepth = DECOR_BASE_DEPTH;
        const frontFace = TILE_DEPTH / 2;
        const alignedPanelZ = frontFace - TILE_DEPTH / 2 + 0.02;
        const baseWidth = width + paddingX * 2;
        const baseHeight = height + paddingY;

        const topCapWidth = width + CUBE_SIZE - GAP;
        const topCapMaterial = new THREE.MeshStandardMaterial({ color: '#f54d52', roughness: 0.4 });
        const topCap = new THREE.Mesh(
          new THREE.BoxGeometry(topCapWidth, CUBE_SIZE * 0.55, TILE_DEPTH),
          topCapMaterial
        );
        topCap.position.y = baseHeight / 2 + CUBE_SIZE * 0.3;
        topCap.position.x = -CUBE_SIZE / 2;
        topCap.castShadow = true;
        topCap.receiveShadow = true;
        decorGroup.add(topCap);

        const studGeometry = new THREE.CylinderGeometry(
          CUBE_SIZE * 0.27,
          CUBE_SIZE * 0.27,
          CUBE_SIZE * 0.28,
          32
        );
        const studMaterial = new THREE.MeshStandardMaterial({
          color: palette.studRed,
          roughness: 0.25,
          metalness: 0.1,
        });
        const studRows = 2;
        const studCols = 4;
        for (let r = 0; r < studRows; r += 1) {
          for (let c = 0; c < studCols; c += 1) {
            const stud = new THREE.Mesh(studGeometry, studMaterial);
            stud.position.set(
              -baseWidth / 2 + CUBE_SIZE * 0.9 + c * CUBE_SIZE * 0.95,
              baseHeight / 2 + CUBE_SIZE * 0.6,
              -CUBE_SIZE * 0.25 + r * CUBE_SIZE * 0.55
            );
            stud.castShadow = true;
            stud.receiveShadow = true;
            decorGroup.add(stud);
          }
        }

        const leftColumnGroup = new THREE.Group();
        decorGroup.add(leftColumnGroup);
        const redMaterial = new THREE.MeshStandardMaterial({
          color: palette.baseRed,
          roughness: 0.35,
          metalness: 0.08,
        });
        const appleTexture = createLeftColumnAppleTexture();
        const appleMaterial = new THREE.MeshStandardMaterial({
          map: appleTexture,
          roughness: 0.35,
          metalness: 0.08,
        });
        const topRedCube = new THREE.Mesh(baseGeometry, redMaterial);
        topRedCube.castShadow = true;
        topRedCube.receiveShadow = true;
        leftColumnGroup.add(topRedCube);
        const leftColumnDayCubes = [];
        for (let row = 0; row < WEEKS_VISIBLE; row += 1) {
          const material = row % 2 === 0 ? appleMaterial : redMaterial;
          const cube = new THREE.Mesh(baseGeometry, material);
          cube.castShadow = true;
          cube.receiveShadow = true;
          leftColumnGroup.add(cube);
          leftColumnDayCubes.push(cube);
        }

        const bottomTexture =
          createBottomPanelTexture(BOTTOM_PANEL_HEIGHT / BOTTOM_PANEL_BASE_HEIGHT);
        const bottomPanelDepth = TILE_DEPTH;
        const bottomCapWidth = topCapWidth;
        const bottomPanel = new THREE.Mesh(
          new THREE.BoxGeometry(bottomCapWidth, BOTTOM_PANEL_HEIGHT, bottomPanelDepth),
          new THREE.MeshStandardMaterial({
            map: bottomTexture,
            roughness: 0.35,
            metalness: 0.05,
          })
        );
        bottomPanel.position.set(-CUBE_SIZE / 2, -baseHeight / 2 + CUBE_SIZE * 0.9, alignedPanelZ);
        bottomPanel.castShadow = true;
        bottomPanel.receiveShadow = true;
        decorGroup.add(bottomPanel);

        const flipTexture = createFlipCardTexture(date);
        const flipMaterial = new THREE.MeshBasicMaterial({ map: flipTexture, side: THREE.DoubleSide });
        const flipCard = new THREE.Mesh(new THREE.PlaneGeometry(CUBE_SIZE * 1.6, CUBE_SIZE * 2.2), flipMaterial);
        const topBarTop = baseHeight / 2 + CUBE_SIZE * 0.3 + CUBE_SIZE * 0.55 * 0.5 + CUBE_SIZE * 0.25;
        const topCapLeft = -topCapWidth / 2;
        const topCapRight = topCapWidth / 2;
        const targetX = topCapLeft + (topCapRight - topCapLeft) * 0.7;
        const flipCardVerticalOffset = CUBE_SIZE * 0.9;
        flipCard.position.set(targetX, topBarTop + flipCardVerticalOffset, 0.25);
        flipCard.rotation.y = Math.PI * -0.04;
        decorGroup.add(flipCard);

        const kittyGroup = new THREE.Group();
        const kittyTargetX = topCapLeft + (topCapRight - topCapLeft) * 0.9;
        kittyGroup.position.set(kittyTargetX, topBarTop + CUBE_SIZE * 0.3, -CUBE_SIZE * 0.35);
        if (kittyTexture && kittyTexture.image) {
          addHiDefKitty(kittyGroup);
        } else {
          addClassicKitty(kittyGroup);
        }

        kittyGroup.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        decorGroup.add(kittyGroup);

        ground.position.y = -baseHeight / 2 - CUBE_SIZE * 0.15;

        return {
          frontFace,
          width,
          height,
          baseWidth,
          baseHeight,
          baseDepth,
          leftColumnTopCube: topRedCube,
          leftColumnDayCubes,
          bottomPanel,
          bottomPanelHeight: BOTTOM_PANEL_HEIGHT,
        };
      }

      function getCalendarCells(baseDate = new Date()) {
        const today = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate());
        const firstOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        const startOffset = firstOfMonth.getDay();
        const gridStart = new Date(firstOfMonth);
        gridStart.setDate(firstOfMonth.getDate() - startOffset);

        monthLabel.textContent = today.toLocaleString('default', {
          month: 'long',
          year: 'numeric',
        });

        const cells = [];
        for (let i = 0; i < DAYS_PER_WEEK * WEEKS_VISIBLE; i += 1) {
          const date = new Date(gridStart);
          date.setDate(gridStart.getDate() + i);
          cells.push({
            date,
            inMonth: date.getMonth() === today.getMonth(),
            isToday: date.getTime() === today.getTime(),
            weekend: date.getDay() === 0 || date.getDay() === 6,
          });
        }
        return cells;
      }

      function createCalendar(baseDate = new Date()) {
        calendarDate = baseDate;
        calendarGroup.clear();
        weekdayGroup.clear();

        const cells = getCalendarCells(baseDate);
        const totalWidth = DAYS_PER_WEEK * (CUBE_SIZE + GAP);
        const totalHeight = WEEKS_VISIBLE * (DAY_HEIGHT + GAP);

        if (!layoutState || layoutState.width !== totalWidth || layoutState.height !== totalHeight) {
          layoutState = buildDecor(totalWidth, totalHeight, baseDate);
        }

        const frontFace = layoutState.frontFace;
        calendarGroup.position.z = frontFace - TILE_DEPTH / 2 + 0.02;
        const weekdayGroupZ = frontFace - TILE_DEPTH / 2 + 0.04;
        weekdayGroup.position.z = weekdayGroupZ;
        const startX = -totalWidth / 2 + (CUBE_SIZE + GAP) / 2;
        const startY = totalHeight / 2 - (DAY_HEIGHT + GAP) / 2;
        const weekdayY = startY + DAY_HEIGHT / 2 + GAP + WEEKDAY_CUBE_HEIGHT / 2;
        const topCapHeight = CUBE_SIZE * 0.55;
        const topCapYOffset = CUBE_SIZE * 0.3;
        const topBlockBottom = layoutState.baseHeight / 2 + topCapYOffset - topCapHeight / 2;
        const weekdayRowTarget = topBlockBottom - GAP - WEEKDAY_CUBE_HEIGHT / 2;
        const gridTopTarget = weekdayRowTarget - (DAY_HEIGHT + GAP);
        calendarGroup.position.y = gridTopTarget - startY;
        weekdayGroup.position.y = weekdayRowTarget - weekdayY;
        const gridBottomTarget = gridTopTarget - (WEEKS_VISIBLE - 1) * (DAY_HEIGHT + GAP);
        if (layoutState.bottomPanel) {
          const bottomCubeBottom = gridBottomTarget - DAY_HEIGHT / 2;
          layoutState.bottomPanel.position.y = bottomCubeBottom - layoutState.bottomPanelHeight / 2 + GAP * 0.5;
        }
        const columnZ = calendarGroup.position.z;
        const leftColumnX = startX - CUBE_SIZE;
        const calendarYOffset = calendarGroup.position.y;
        if (layoutState.leftColumnDayCubes) {
          layoutState.leftColumnDayCubes.forEach((cube, row) => {
            const y = startY - row * (DAY_HEIGHT + GAP);
            cube.position.set(leftColumnX, calendarYOffset + y, columnZ);
          });
        }
        if (layoutState.leftColumnTopCube) {
          const weekdayTop = weekdayGroup.position.y + weekdayY + WEEKDAY_CUBE_HEIGHT / 2;
          layoutState.leftColumnTopCube.position.set(leftColumnX, weekdayTop - DAY_HEIGHT / 2, columnZ);
        }
        const eventTextures = eventSpecs.map((spec) => createEventBrickTexture({ ...spec, icon: null }));
        const iconTextures = iconSpecs.map((spec) => createEventBrickTexture({ label: '', accent: spec.accent, icon: spec.icon }));
        const lastActiveIndex = cells.reduce((acc, cell, idx) => (cell.inMonth ? idx : acc), -1);
        const extraSlots = new Map();
        let nextIdx = lastActiveIndex + 1;
        eventTextures.forEach((texture) => {
          if (nextIdx < cells.length) {
            extraSlots.set(nextIdx, texture);
            nextIdx += 1;
          }
        });
        iconTextures.forEach((texture) => {
          if (nextIdx < cells.length) {
            extraSlots.set(nextIdx, texture);
            nextIdx += 1;
          }
        });

        cells.forEach((cell, idx) => {
          const col = idx % DAYS_PER_WEEK;
          const row = Math.floor(idx / DAYS_PER_WEEK);
          const extraTexture = extraSlots.get(idx);
          if (extraTexture) {
            const material = new THREE.MeshStandardMaterial({
              map: extraTexture,
              color: 0xffffff,
              metalness: 0.05,
              roughness: 0.6,
            });

            const cube = new THREE.Mesh(baseGeometry, material);
            cube.position.set(
              startX + col * (CUBE_SIZE + GAP),
              startY - row * (DAY_HEIGHT + GAP),
              0
            );
            cube.castShadow = true;
            cube.receiveShadow = true;
            calendarGroup.add(cube);
            return;
          }

          if (!cell.inMonth) {
            const cube = new THREE.Mesh(baseGeometry, emptyDayMaterial);
            cube.position.set(
              startX + col * (CUBE_SIZE + GAP),
              startY - row * (DAY_HEIGHT + GAP),
              0
            );
            cube.castShadow = true;
            cube.receiveShadow = true;
            calendarGroup.add(cube);
            return;
          }

          const texture = createDayTexture({
            label: cell.date.getDate().toString(),
            active: cell.inMonth,
            highlight: cell.isToday,
            weekend: cell.weekend,
          });

          const material = new THREE.MeshStandardMaterial({
            map: texture,
            color: 0xffffff,
            metalness: 0.05,
            roughness: 0.6,
          });

          const cube = new THREE.Mesh(baseGeometry, material);
          cube.position.set(
            startX + col * (CUBE_SIZE + GAP),
            startY - row * (DAY_HEIGHT + GAP),
            0
          );
          cube.castShadow = true;
          cube.receiveShadow = true;
          calendarGroup.add(cube);
        });

        // Weekday labels sit slightly above cubes
        weekdays.forEach((day, idx) => {
          const spriteMap = createWeekdayTexture(day, idx === 0 || idx === 6);
          const material = new THREE.MeshStandardMaterial({
            map: spriteMap,
            roughness: 0.45,
            metalness: 0.05,
          });
          const cube = new THREE.Mesh(WEEKDAY_CUBE_GEOMETRY, material);
          cube.position.set(
            startX + idx * (CUBE_SIZE + GAP),
            weekdayY,
            0
          );
          cube.castShadow = true;
          cube.receiveShadow = true;
          weekdayGroup.add(cube);
        });
      }

      createCalendar(calendarDate);

      window.addEventListener('resize', onResize);

      function onResize() {
        const { clientWidth, clientHeight } = container;
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        calendarRig.rotation.y += 0.0005;
        calendarRig.rotation.x = THREE.MathUtils.lerp(calendarRig.rotation.x, 0.1, 0.02);
        controls.update();
        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
