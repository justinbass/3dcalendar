<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Calendar • Three.js</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Baloo+2:wght@600&family=Nunito:wght@500;700&display=swap');

      :root {
        font-family: 'Baloo 2', 'Nunito', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: radial-gradient(circle at top, #ffe6c9 0%, #ffc278 45%, #f7974c 100%);
        color: #1b3d91;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background: radial-gradient(circle at top, #ffe6c9 0%, #ffc278 45%, #f7974c 100%);
      }

      #scene-container {
        flex: 1;
        position: relative;
        box-shadow: inset 0 40px 120px rgba(255, 255, 255, 0.45);
      }

      canvas {
        display: block;
      }

      .overlay {
        position: absolute;
        inset: 1rem 1rem auto auto;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        text-align: right;
      }

      .overlay span {
        font-size: 0.95rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #c41230;
        text-shadow: 0 2px 4px rgba(255, 255, 255, 0.6);
      }

      .overlay small {
        font-size: 0.75rem;
        letter-spacing: 0.15em;
        color: rgba(27, 61, 145, 0.75);
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div id="scene-container">
      <div class="overlay">
        <span id="month-label"></span>
        <small>Drag to rotate · Scroll to zoom</small>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      const container = document.getElementById('scene-container');
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        100
      );
      camera.position.set(22, 16, 32);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(
        'image.png',
        (texture) => {
          texture.colorSpace = THREE.SRGBColorSpace;
          texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
          kittyTexture = texture;
          createCalendar(calendarDate);
        },
        undefined,
        (error) => {
          console.warn('Unable to load hi-def kitty texture:', error);
        }
      );

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(0, 0, 0);
      controls.minDistance = 10;
      controls.maxDistance = 26;
      controls.update();

      const ambient = new THREE.AmbientLight(0xffffff, 0.55);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
      dirLight.position.set(6, 12, 10);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.set(2048, 2048);
      scene.add(dirLight);

      const monthLabel = document.getElementById('month-label');
      const DAYS_PER_WEEK = 7;
      const WEEKS_VISIBLE = 6;
      const CUBE_SIZE = 1.4;
      const GAP = 0.02;
      const palette = {
        baseRed: '#1c3fc8',
        studRed: '#2e5ce0',
        warmWhite: '#f6f7ff',
        ivory: '#f8f9ff',
        accentBlue: '#7fa5ff',
        numberBlue: '#0d1b72',
        weekendPink: '#5e7cff',
        weekdaysRed: '#0f1e5d',
        weekendLabel: '#153ea0',
        todaySunshine: '#72c7ff',
        subtleOutline: '#9aacff',
        bowRed: '#4f6fff',
        kittyWhite: '#ffffff',
        kittyNose: '#b6d4ff',
      };

      const monthPortalPalettes = [
        { inner: '#ff87d5', outer: '#fff3fb', sparks: '#ffd6ff', rings: ['#ff9ee5', '#ffd3f5'], haze: '#ffe1ff' },
        { inner: '#ffa67a', outer: '#fff1e3', sparks: '#fff5d6', rings: ['#ffcb9b', '#ffe6c7'], haze: '#fff7dd' },
        { inner: '#6ce6ff', outer: '#e3fbff', sparks: '#c9f2ff', rings: ['#8be5ff', '#d2f7ff'], haze: '#eaffff' },
        { inner: '#7effc2', outer: '#ecfffb', sparks: '#d5ffe9', rings: ['#92ffd2', '#cafff1'], haze: '#e3fff4' },
        { inner: '#7f98ff', outer: '#eef0ff', sparks: '#d3d8ff', rings: ['#a4b7ff', '#ced6ff'], haze: '#f5f6ff' },
        { inner: '#ff8bb0', outer: '#ffe3ee', sparks: '#ffcfe2', rings: ['#ff9fc4', '#ffd3e9'], haze: '#ffeef5' },
        { inner: '#ffcf57', outer: '#fff6dd', sparks: '#ffe5a3', rings: ['#ffd986', '#fff2c4'], haze: '#fff9e6' },
        { inner: '#70f9ff', outer: '#e0ffff', sparks: '#c9faff', rings: ['#8ffcff', '#d9feff'], haze: '#ecffff' },
        { inner: '#9e87ff', outer: '#f5edff', sparks: '#e0d2ff', rings: ['#b49eff', '#e6d8ff'], haze: '#f9f6ff' },
        { inner: '#ff9d6c', outer: '#ffe8d9', sparks: '#ffd2bc', rings: ['#ffb489', '#ffe1c8'], haze: '#fff2eb' },
        { inner: '#7de4ff', outer: '#e7fbff', sparks: '#c8f0ff', rings: ['#9ae9ff', '#d6f8ff'], haze: '#f0fdff' },
        { inner: '#ffc1f3', outer: '#fff2fb', sparks: '#ffe1fa', rings: ['#ffd0f7', '#ffe8fb'], haze: '#fff7fc' },
      ];

      const chronoPortalState = {
        group: null,
        portalMesh: null,
        uniforms: null,
        sparks: [],
        rings: [],
        pointer: new THREE.Vector2(0, 0),
        parallax: new THREE.Vector2(0, 0),
        anchor: new THREE.Vector3(0, 0, 0),
        tempPosition: new THREE.Vector3(0, 0, 0),
        portalRadius: CUBE_SIZE * 5.2,
        pulseLight: null,
        hazeMesh: null,
      };

      const WEEKDAY_CUBE_HEIGHT = CUBE_SIZE * 0.45;
      const DAY_HEIGHT = CUBE_SIZE * 0.5;
      const BOTTOM_PANEL_HEIGHT = DAY_HEIGHT * 2;
      const BOTTOM_PANEL_BASE_HEIGHT = CUBE_SIZE * 1.6;

      const eventSpecs = [
        { label: 'Birthday', accent: '#ffb7d5', labelScale: 0.15 },
        { label: 'Travel', accent: '#c4e1ff', labelScale: 0.18 },
      ];
      const iconSpecs = [
        { accent: '#ffdbe8', icon: 'apple' },
        { accent: '#d5e9ff', icon: 'bow' },
      ];

      const DIGITAL_CLOCK_WIDTH = CUBE_SIZE * 1.1;
      const DIGITAL_CLOCK_HEIGHT = CUBE_SIZE * 0.5;
      const DIGITAL_CLOCK_DEPTH = CUBE_SIZE * 0.45;
      const GRADIENT_PANEL_WIDTH = CUBE_SIZE * 0.64;
      const GRADIENT_PANEL_HEIGHT = CUBE_SIZE * 2.6;
      const digitalClockState = {
        canvas: null,
        ctx: null,
        texture: null,
        mesh: null,
        haloPivot: null,
      };
      const floatingAuraState = {
        group: null,
        radius: null,
      };
      const formatTwoDigits = (value) => value.toString().padStart(2, '0');

      function ensureDigitalClockCanvas() {
        if (digitalClockState.canvas) {
          return digitalClockState;
        }
        digitalClockState.canvas = Object.assign(document.createElement('canvas'), {
          width: 1024,
          height: 512,
        });
        digitalClockState.ctx = digitalClockState.canvas.getContext('2d');
        digitalClockState.texture = new THREE.CanvasTexture(digitalClockState.canvas);
        digitalClockState.texture.encoding = THREE.sRGBColorSpace;
        digitalClockState.texture.minFilter = THREE.LinearFilter;
        digitalClockState.texture.magFilter = THREE.LinearFilter;
        return digitalClockState;
      }

      function drawDigitalClockFace(date = new Date()) {
        const { ctx, canvas, texture } = ensureDigitalClockCanvas();
        if (!ctx || !canvas || !texture) {
          return;
        }
        ctx.fillStyle = '#020610';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0f1b39';
        ctx.fillRect(0, canvas.height * 0.05, canvas.width, canvas.height * 0.9);
        ctx.fillStyle = '#4ac9ff';
        ctx.globalAlpha = 0.35;
        ctx.fillRect(canvas.width * 0.05, canvas.height * 0.75, canvas.width * 0.9, canvas.height * 0.18);
        ctx.globalAlpha = 1;
        ctx.font = `900 ${canvas.height * 0.55}px 'Baloo 2', 'Nunito', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const timeText = `${formatTwoDigits(date.getHours())}:${formatTwoDigits(date.getMinutes())}`;
        ctx.fillStyle = '#73d9ff';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.35)';
        ctx.shadowBlur = canvas.height * 0.03;
        ctx.fillText(timeText, canvas.width / 2, canvas.height / 2);
        ctx.shadowBlur = 0;
        ctx.font = `600 ${canvas.height * 0.17}px 'Baloo 2', 'Nunito', sans-serif`;
        ctx.fillStyle = '#8ccbff';
        ctx.fillText('24 HOUR', canvas.width / 2, canvas.height * 0.85);
        texture.needsUpdate = true;
      }

      function createClockHaloParticles() {
        const group = new THREE.Group();
        const dotGeometry = new THREE.SphereGeometry(DIGITAL_CLOCK_HEIGHT * 0.12, 16, 12);
        const dotMaterial = new THREE.MeshStandardMaterial({
          color: '#8ef0ff',
          emissive: '#52ccff',
          emissiveIntensity: 0.8,
          roughness: 0.15,
          metalness: 0.35,
          transparent: true,
          opacity: 0.9,
        });
        const dotCount = 10;
        const radius = DIGITAL_CLOCK_WIDTH * 0.85;
        for (let i = 0; i < dotCount; i += 1) {
          const angle = (i / dotCount) * Math.PI * 2;
          const dot = new THREE.Mesh(dotGeometry, dotMaterial);
          dot.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * (radius * 0.4));
          group.add(dot);
        }
        return group;
      }

      function createDigitalClockMesh() {
        if (digitalClockState.mesh) {
          return digitalClockState.mesh;
        }
        const geometry = new THREE.BoxGeometry(
          DIGITAL_CLOCK_WIDTH,
          DIGITAL_CLOCK_HEIGHT,
          DIGITAL_CLOCK_DEPTH
        );
        const darkMaterial = new THREE.MeshStandardMaterial({
          color: '#050a1b',
          roughness: 0.35,
          metalness: 0.6,
        });
        const frontMaterial = new THREE.MeshStandardMaterial({
          map: ensureDigitalClockCanvas().texture,
          emissive: '#1d5bff',
          emissiveIntensity: 0.7,
          roughness: 0.2,
          metalness: 0.3,
        });
        const materials = [
          darkMaterial, // right
          darkMaterial, // left
          darkMaterial, // top
          darkMaterial, // bottom
          frontMaterial, // front
          darkMaterial, // back
        ];
        const mesh = new THREE.Mesh(geometry, materials);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        const haloPivot = new THREE.Group();
        haloPivot.userData.isDigitalClockHalo = true;
        haloPivot.add(createClockHaloParticles());
        haloPivot.position.set(0, 0, DIGITAL_CLOCK_DEPTH * 0.55);
        mesh.add(haloPivot);
        digitalClockState.haloPivot = haloPivot;
        digitalClockState.mesh = mesh;
        return mesh;
      }

      function createFloatingAuraParticles(radius) {
        const group = new THREE.Group();
        const particleGeo = new THREE.CylinderGeometry(DIGITAL_CLOCK_HEIGHT * 0.08, DIGITAL_CLOCK_HEIGHT * 0.08, DIGITAL_CLOCK_HEIGHT * 0.3, 12);
        const particleMat = new THREE.MeshStandardMaterial({
          color: '#c9fbff',
          emissive: '#6fdfff',
          emissiveIntensity: 0.6,
          roughness: 0.15,
          metalness: 0.45,
        });
        const particleCount = 12;
        for (let i = 0; i < particleCount; i += 1) {
          const angle = (i / particleCount) * Math.PI * 2;
          const particle = new THREE.Mesh(particleGeo, particleMat);
          particle.rotation.x = Math.PI / 2;
          particle.position.set(Math.cos(angle) * radius, DIGITAL_CLOCK_HEIGHT * 0.2, Math.sin(angle) * radius * 0.5);
          particle.userData = {
            baseY: particle.position.y,
            offset: angle,
          };
          group.add(particle);
        }
        return group;
      }

      function createGradientPlane() {
        const canvas = document.createElement('canvas');
        const width = 512;
        const height = 1024;
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, 'rgba(110, 188, 255, 0.9)');
        grad.addColorStop(0.45, 'rgba(90, 160, 255, 0.65)');
        grad.addColorStop(1, 'rgba(40, 110, 255, 0.35)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        for (let i = 0; i < 8; i += 1) {
          ctx.fillRect(0, (i / 8) * height, width, 6);
        }
        const texture = new THREE.CanvasTexture(canvas);
        texture.encoding = THREE.sRGBColorSpace;
        texture.needsUpdate = true;
        return texture;
      }

      const portalVertexShader = /* glsl */ `
        varying vec2 vUv;
        uniform float uTime;
        uniform vec2 uParallax;
        void main() {
          vUv = uv;
          vec3 distorted = position;
          float rippleOne = sin((uv.y + uTime * 0.25) * 18.0) * 0.08;
          float rippleTwo = cos((uv.x + uTime * 0.4) * 14.0) * 0.06;
          distorted.z += rippleOne + rippleTwo;
          distorted.xy += uParallax * 0.4;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(distorted, 1.0);
        }
      `;

      const portalFragmentShader = /* glsl */ `
        varying vec2 vUv;
        uniform float uTime;
        uniform vec3 uColorInner;
        uniform vec3 uColorOuter;
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }
        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        void main() {
          vec2 centered = vUv - 0.5;
          float len = length(centered) * 2.0;
          float swirl = atan(centered.y, centered.x);
          float time = uTime * 0.45;
          float ripple = sin(len * 20.0 - time * 10.0 + swirl * 3.5);
          float flow = noise(centered * 8.0 + time * 0.6);
          float glow = smoothstep(1.35, 0.0, len + flow * 0.3);
          float filament = smoothstep(0.8, 0.15, abs(ripple)) * 0.6;
          vec3 baseColor = mix(uColorInner, uColorOuter, clamp(len, 0.0, 1.0));
          vec3 color = baseColor * (0.6 + flow * 0.5) + vec3(1.0) * filament * 0.45;
          color += baseColor * pow(glow, 1.4);
          float alpha = glow * 0.85 + filament * 0.3;
          if (alpha < 0.025) discard;
          gl_FragColor = vec4(color, alpha);
        }
      `;

      function ensureChronoPortal() {
        if (chronoPortalState.group) {
          return chronoPortalState.group;
        }
        const group = new THREE.Group();
        chronoPortalState.group = group;

        const uniforms = {
          uTime: { value: 0 },
          uColorInner: { value: new THREE.Color('#ff9ff2') },
          uColorOuter: { value: new THREE.Color('#ffe6fb') },
          uParallax: { value: new THREE.Vector2(0, 0) },
        };
        chronoPortalState.uniforms = uniforms;

        const geometry = new THREE.CircleGeometry(chronoPortalState.portalRadius, 160);
        const material = new THREE.ShaderMaterial({
          uniforms,
          vertexShader: portalVertexShader,
          fragmentShader: portalFragmentShader,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide,
        });
        const portalMesh = new THREE.Mesh(geometry, material);
        portalMesh.rotation.y = Math.PI;
        group.add(portalMesh);
        chronoPortalState.portalMesh = portalMesh;

        const ringRadii = [0.55, 0.78, 0.98];
        ringRadii.forEach((ratio, index) => {
          const ringGeometry = new THREE.TorusGeometry(
            chronoPortalState.portalRadius * ratio,
            CUBE_SIZE * (0.08 + index * 0.02),
            40,
            240
          );
          const ringMaterial = new THREE.MeshStandardMaterial({
            color: '#fff6ff',
            emissive: '#ffd6ff',
            emissiveIntensity: 0.35 + index * 0.15,
            roughness: 0.25,
            metalness: 0.6,
            transparent: true,
            opacity: 0.9 - index * 0.15,
          });
          const ring = new THREE.Mesh(ringGeometry, ringMaterial);
          ring.rotation.x = Math.PI / 2.3;
          ring.rotation.y = index * 0.3;
          ring.userData.spin = index % 2 === 0 ? 1 : -1;
          chronoPortalState.rings.push(ring);
          group.add(ring);
        });

        const sparkGeometry = new THREE.SphereGeometry(CUBE_SIZE * 0.1, 16, 12);
        const sparkCount = 42;
        for (let i = 0; i < sparkCount; i += 1) {
          const sparkMaterial = new THREE.MeshBasicMaterial({
            color: '#f5ffff',
            transparent: true,
            opacity: 0.75,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
          });
          const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
          spark.userData = {
            radius: chronoPortalState.portalRadius * (0.3 + Math.random() * 0.55),
            speed: 0.2 + Math.random() * 0.35,
            offset: Math.random() * Math.PI * 2,
            lift: CUBE_SIZE * (0.35 + Math.random() * 0.55),
          };
          chronoPortalState.sparks.push(spark);
          group.add(spark);
        }

        const hazeGeometry = new THREE.CircleGeometry(chronoPortalState.portalRadius * 1.26, 90);
        const hazeMaterial = new THREE.MeshBasicMaterial({
          color: '#ffeefd',
          transparent: true,
          opacity: 0.18,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });
        const hazeMesh = new THREE.Mesh(hazeGeometry, hazeMaterial);
        hazeMesh.rotation.y = Math.PI;
        hazeMesh.position.z = -CUBE_SIZE * 0.1;
        group.add(hazeMesh);
        chronoPortalState.hazeMesh = hazeMesh;

        chronoPortalState.pulseLight = new THREE.PointLight('#ffeaff', 2.1, CUBE_SIZE * 16, 2);
        chronoPortalState.pulseLight.position.set(0, 0, chronoPortalState.portalRadius * 0.05);
        group.add(chronoPortalState.pulseLight);

        return group;
      }

      function updateChronoPortalPalette(date) {
        if (!chronoPortalState.uniforms) {
          return;
        }
        const palette = monthPortalPalettes[date.getMonth() % monthPortalPalettes.length];
        chronoPortalState.uniforms.uColorInner.value.set(palette.inner);
        chronoPortalState.uniforms.uColorOuter.value.set(palette.outer);
        if (chronoPortalState.hazeMesh) {
          chronoPortalState.hazeMesh.material.color.set(palette.haze);
        }
        chronoPortalState.sparks.forEach((spark) => {
          spark.material.color.set(palette.sparks);
        });
        chronoPortalState.rings.forEach((ring, index) => {
          const ringColor = palette.rings[index % palette.rings.length];
          ring.material.color.set(ringColor);
          if (ring.material.emissive) {
            ring.material.emissive.set(ringColor);
          }
        });
        if (chronoPortalState.pulseLight) {
          chronoPortalState.pulseLight.color.set(palette.sparks);
        }
      }

      function updateChronoPortalLayout(date, metrics) {
        const group = ensureChronoPortal();
        const { baseWidth, baseHeight, baseDepth } = metrics;
        const scale = THREE.MathUtils.clamp(baseWidth / (CUBE_SIZE * 6), 0.7, 1.4);
        group.scale.setScalar(scale);
        chronoPortalState.anchor.set(-CUBE_SIZE * 0.25, baseHeight * 0.18, -baseDepth * 0.55);
        group.position.copy(chronoPortalState.anchor);
        updateChronoPortalPalette(date);
      }

      drawDigitalClockFace();
      setInterval(() => drawDigitalClockFace(new Date()), 1000);

      let calendarDate = new Date();
      let kittyTexture = null;

      const RIG_ELEVATION = CUBE_SIZE * 1.5;
      const calendarRig = new THREE.Group();
      calendarRig.position.y = RIG_ELEVATION;
      scene.add(calendarRig);
      const ground = new THREE.Mesh(
        new THREE.CircleGeometry(26, 64),
        new THREE.MeshStandardMaterial({ color: '#f0ad72', roughness: 1, metalness: 0 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      const calendarGroup = new THREE.Group();
      const weekdayGroup = new THREE.Group();
      const decorGroup = new THREE.Group();
      calendarRig.add(decorGroup);
      calendarRig.add(calendarGroup);
      calendarRig.add(weekdayGroup);
      const chronoPortalGroup = ensureChronoPortal();
      calendarRig.add(chronoPortalGroup);
      chronoPortalState.anchor.set(0, 0, -CUBE_SIZE * 3);
      chronoPortalGroup.position.copy(chronoPortalState.anchor);

      calendarGroup.position.y = CUBE_SIZE * 0.85;
      weekdayGroup.position.y = CUBE_SIZE * 0.85;

      const DECOR_BASE_DEPTH = CUBE_SIZE * 1.4;
      const TILE_DEPTH = DECOR_BASE_DEPTH * 0.94;
      const baseGeometry = new THREE.BoxGeometry(CUBE_SIZE, DAY_HEIGHT, TILE_DEPTH);
      const WEEKDAY_CUBE_GEOMETRY = new THREE.BoxGeometry(CUBE_SIZE, WEEKDAY_CUBE_HEIGHT, TILE_DEPTH);
      const emptyDayMaterial = new THREE.MeshStandardMaterial({
        color: palette.baseRed,
        roughness: 0.55,
        metalness: 0.1,
      });

      const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      let layoutState = null;
      const auroraPanels = [];

      const NUMBER_X_SCALE = 0.78;
      function padTextureText(ctx, label, size) {
        ctx.save();
        ctx.translate(size / 2, size * 0.6);
        ctx.scale(NUMBER_X_SCALE, 1);
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }

      function createDayTexture({ label, active, highlight, weekend }) {
        const size = 512;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size,
        });
        const ctx = canvas.getContext('2d');

        const showDateNumber = active || highlight;
        const background = highlight
          ? palette.todaySunshine
          : weekend && active
          ? palette.weekendPink
          : showDateNumber
          ? palette.warmWhite
          : palette.baseRed;
        const border = highlight ? '#f9c74f' : showDateNumber ? palette.subtleOutline : palette.baseRed;
        const textColor = highlight ? palette.baseRed : weekend ? palette.weekendLabel : palette.numberBlue;

        ctx.fillStyle = background;
        ctx.strokeStyle = border;
        ctx.lineWidth = size * 0.04;
        ctx.fillRect(0, 0, size, size);
        ctx.strokeRect(
          ctx.lineWidth / 2,
          ctx.lineWidth / 2,
          size - ctx.lineWidth,
          size - ctx.lineWidth
        );

        if (showDateNumber) {
          ctx.fillStyle = textColor;
          const fontSize = size * 0.32;
          ctx.font = `600 ${fontSize}px 'Nunito', 'Baloo 2', sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = 'rgba(0,0,0,0.08)';
          ctx.shadowBlur = size * 0.04;
          padTextureText(ctx, label, size);
          ctx.shadowBlur = 0;
        }

        if (weekend && !highlight) {
          ctx.fillStyle = 'rgba(255, 48, 74, 0.18)';
          ctx.beginPath();
          ctx.arc(size * 0.82, size * 0.2, size * 0.07, 0, Math.PI * 2);
          ctx.fill();
        }

        return new THREE.CanvasTexture(canvas);
      }

      function createWeekdayTexture(label, weekend) {
        const size = 512;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size,
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = weekend ? palette.weekendLabel : palette.weekdaysRed;
        ctx.fillRect(0, 0, size, size);
        ctx.fillStyle = palette.warmWhite;
        ctx.font = `700 ${size * 0.34}px 'Baloo 2', 'Nunito', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0,0,0,0.18)';
        ctx.shadowBlur = size * 0.04;
        ctx.fillText(label, size / 2, size / 2);
        return new THREE.CanvasTexture(canvas);
      }

      function drawApple(ctx, x, y, radius) {
        ctx.fillStyle = '#ff3b30';
        ctx.strokeStyle = '#ce0f1d';
        ctx.lineWidth = radius * 0.25;
        ctx.beginPath();
        ctx.arc(x - radius * 0.3, y, radius, 0, Math.PI * 2);
        ctx.arc(x + radius * 0.3, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(x, y + radius * 0.05, radius * 0.95, radius * 0.9, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#3e9c44';
        ctx.beginPath();
        ctx.ellipse(x - radius * 0.2, y - radius * 0.85, radius * 0.4, radius * 0.5, 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(x + radius * 0.2, y - radius * 0.9, radius * 0.3, radius * 0.45, -0.5, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawAppleScaled(ctx, x, y, radius, xScale = 1, yScale = 1) {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(xScale, yScale);
        drawApple(ctx, 0, 0, radius);
        ctx.restore();
      }

      function createLeftColumnAppleTexture() {
        const size = 512;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size,
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = palette.warmWhite;
        ctx.fillRect(0, 0, size, size);
        drawAppleScaled(ctx, size / 2, size / 2, size * 0.3, 0.5, 1);
        return new THREE.CanvasTexture(canvas);
      }

      function drawBow(ctx, x, y, size) {
        ctx.fillStyle = palette.bowRed;
        ctx.strokeStyle = '#a01120';
        ctx.lineWidth = size * 0.12;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x - size, y - size * 0.4, x - size * 1.1, y + size * 0.5, x - size * 0.2, y + size * 0.1);
        ctx.bezierCurveTo(x - size * 1.1, y + size * 0.6, x - size * 0.3, y + size * 1, x, y + size * 0.3);
        ctx.bezierCurveTo(x + size * 0.3, y + size * 1, x + size * 1.1, y + size * 0.6, x + size * 0.2, y + size * 0.1);
        ctx.bezierCurveTo(x + size * 1.1, y + size * 0.5, x + size, y - size * 0.4, x, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.fillStyle = '#ff7b8c';
        ctx.arc(x, y + size * 0.2, size * 0.35, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawKittyFace(ctx, x, y, size) {
        ctx.fillStyle = palette.kittyWhite;
        ctx.beginPath();
        ctx.ellipse(x, y, size, size * 0.85, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(x - size * 0.6, y - size * 0.2);
        ctx.lineTo(x - size * 0.3, y - size * 0.9);
        ctx.lineTo(x - size * 0.05, y - size * 0.2);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(x + size * 0.6, y - size * 0.2);
        ctx.lineTo(x + size * 0.3, y - size * 0.9);
        ctx.lineTo(x + size * 0.05, y - size * 0.2);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = palette.accentBlue;
        ctx.beginPath();
        ctx.arc(x - size * 0.3, y - size * 0.05, size * 0.12, 0, Math.PI * 2);
        ctx.arc(x + size * 0.3, y - size * 0.05, size * 0.12, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = palette.kittyNose;
        ctx.beginPath();
        ctx.ellipse(x, y + size * 0.05, size * 0.18, size * 0.12, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#d9c7cf';
        ctx.lineWidth = size * 0.06;
        ctx.beginPath();
        ctx.moveTo(x - size * 0.7, y + size * 0.1);
        ctx.lineTo(x - size * 0.35, y + size * 0.05);
        ctx.moveTo(x + size * 0.7, y + size * 0.1);
        ctx.lineTo(x + size * 0.35, y + size * 0.05);
        ctx.stroke();

        drawBow(ctx, x + size * 0.55, y - size * 0.45, size * 0.45);
      }

      function createBottomPanelTexture(heightFactor = 1) {
        const canvas = Object.assign(document.createElement('canvas'), {
          width: 2048,
          height: Math.max(128, Math.round(640 * heightFactor)),
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = palette.baseRed;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawKittyFace(ctx, canvas.width * 0.1, canvas.height * 0.55, canvas.height * 0.35);
        ctx.fillStyle = '#fff';
        ctx.font = `700 ${canvas.height * 0.35}px 'Baloo 2', 'Nunito', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('HELLO CATTY', canvas.width * 0.55, canvas.height * 0.55);
        drawBow(ctx, canvas.width * 0.88, canvas.height * 0.5, canvas.height * 0.22);
        return new THREE.CanvasTexture(canvas);
      }

      function createEventBrickTexture({ label, accent, icon, labelScale = 0.18 }) {
        const size = 512;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size,
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, size, size);
        ctx.strokeStyle = accent;
        ctx.lineWidth = size * 0.1;
        ctx.strokeRect(ctx.lineWidth / 2, ctx.lineWidth / 2, size - ctx.lineWidth, size - ctx.lineWidth);
        const iconCenterX = label ? size * 0.2 : size * 0.5;
        const iconCenterY = label ? size * 0.45 : size * 0.5;
        const iconScale = label ? 0.18 : 0.28;
        if (icon === 'apple') {
          drawAppleScaled(ctx, iconCenterX, iconCenterY, size * iconScale, 0.5, 1);
        } else if (icon === 'bow') {
          drawBow(ctx, iconCenterX, iconCenterY, size * iconScale);
        }
        if (!label) {
          return new THREE.CanvasTexture(canvas);
        }
        ctx.fillStyle = palette.numberBlue;
        ctx.font = `700 ${size * labelScale}px 'Nunito', 'Baloo 2', sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label.toUpperCase(), size / 2, size * 0.57);
        return new THREE.CanvasTexture(canvas);
      }

      function createFlipCardTexture(date = new Date()) {
        const size = 1024;
        const canvas = Object.assign(document.createElement('canvas'), {
          width: size,
          height: size * 1.2,
        });
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = palette.warmWhite;
        ctx.strokeStyle = '#d9d9d9';
        ctx.lineWidth = size * 0.04;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeRect(
          ctx.lineWidth / 2,
          ctx.lineWidth / 2,
          canvas.width - ctx.lineWidth,
          canvas.height - ctx.lineWidth
        );
        const dayLabel = date.getDate().toString();
        const monthLabel = date
          .toLocaleString('default', { month: 'long' })
          .toUpperCase();
        ctx.fillStyle = palette.numberBlue;
        ctx.font = `700 ${size * 0.7}px 'Baloo 2', 'Nunito', sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(dayLabel, canvas.width / 2, canvas.height * 0.45);
        ctx.fillStyle = palette.accentBlue;
        ctx.font = `600 ${size * 0.18}px 'Nunito', sans-serif`;
        ctx.fillText(monthLabel, canvas.width / 2, canvas.height * 0.78);
        return new THREE.CanvasTexture(canvas);
      }

      function addClassicKitty(kittyGroup) {
        const kittyMaterial = new THREE.MeshStandardMaterial({
          color: palette.kittyWhite,
          roughness: 0.35,
          metalness: 0.05,
        });
        const head = new THREE.Mesh(new THREE.SphereGeometry(CUBE_SIZE * 0.55, 32, 32), kittyMaterial);
        head.scale.y = 0.85;
        head.position.y = CUBE_SIZE * 0.2;
        kittyGroup.add(head);

        const body = new THREE.Mesh(
          new THREE.BoxGeometry(CUBE_SIZE * 0.65, CUBE_SIZE * 0.6, CUBE_SIZE * 0.4),
          new THREE.MeshStandardMaterial({ color: palette.accentBlue, metalness: 0.05, roughness: 0.5 })
        );
        body.position.set(0, -CUBE_SIZE * 0.2, 0);
        kittyGroup.add(body);

        const nose = new THREE.Mesh(
          new THREE.SphereGeometry(CUBE_SIZE * 0.08, 16, 16),
          new THREE.MeshStandardMaterial({ color: palette.kittyNose })
        );
        nose.position.set(0, CUBE_SIZE * 0.25, CUBE_SIZE * 0.45);
        kittyGroup.add(nose);

        const eyeGeometry = new THREE.SphereGeometry(CUBE_SIZE * 0.07, 16, 16);
        const eyeMaterial = new THREE.MeshStandardMaterial({ color: palette.accentBlue, roughness: 0.3 });
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.scale.y = 1.35;
        rightEye.scale.y = 1.35;
        leftEye.position.set(-CUBE_SIZE * 0.23, CUBE_SIZE * 0.28, CUBE_SIZE * 0.48);
        rightEye.position.set(CUBE_SIZE * 0.23, CUBE_SIZE * 0.28, CUBE_SIZE * 0.48);
        kittyGroup.add(leftEye, rightEye);

        const whiskerGeometry = new THREE.BoxGeometry(CUBE_SIZE * 0.42, CUBE_SIZE * 0.02, CUBE_SIZE * 0.02);
        const whiskerMaterial = new THREE.MeshStandardMaterial({ color: '#d7cdd3', roughness: 0.6 });
        for (let i = 0; i < 2; i += 1) {
          const whisker = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
          whisker.position.set(-CUBE_SIZE * 0.42, CUBE_SIZE * (0.18 - i * 0.08), CUBE_SIZE * 0.35);
          whisker.rotation.z = THREE.MathUtils.degToRad(i === 0 ? -5 : 8);
          kittyGroup.add(whisker);
          const mirror = whisker.clone();
          mirror.position.x *= -1;
          mirror.rotation.z *= -1;
          kittyGroup.add(mirror);
        }

        const bow = new THREE.Mesh(
          new THREE.TorusGeometry(CUBE_SIZE * 0.25, CUBE_SIZE * 0.09, 16, 32),
          new THREE.MeshStandardMaterial({ color: palette.bowRed, metalness: 0.2, roughness: 0.35 })
        );
        bow.rotation.order = 'ZYX';
        bow.rotation.y = Math.PI / 2;
        bow.rotation.z = THREE.MathUtils.degToRad(-120);
        bow.position.set(CUBE_SIZE * 0.35, CUBE_SIZE * 0.55, 0);
        kittyGroup.add(bow);

        const earGeometry = new THREE.ConeGeometry(CUBE_SIZE * 0.18, CUBE_SIZE * 0.3, 16);
        const leftEar = new THREE.Mesh(earGeometry, kittyMaterial);
        const rightEar = new THREE.Mesh(earGeometry, kittyMaterial);
        leftEar.rotation.set(0, 0, 0);
        rightEar.rotation.set(0, 0, 0);
        leftEar.position.set(-CUBE_SIZE * 0.32, CUBE_SIZE * 0.63, -CUBE_SIZE * 0.02);
        rightEar.position.set(CUBE_SIZE * 0.32, CUBE_SIZE * 0.63, -CUBE_SIZE * 0.02);
        kittyGroup.add(leftEar, rightEar);
      }

      function addHiDefKitty(kittyGroup) {
        if (!kittyTexture || !kittyTexture.image) {
          addClassicKitty(kittyGroup);
          return;
        }

        const aspect = kittyTexture.image.width
          ? kittyTexture.image.height / kittyTexture.image.width
          : 1;
        const displayWidth = CUBE_SIZE * 2.6;
        const displayHeight = displayWidth * aspect;
        const frameDepth = CUBE_SIZE * 0.15;

        const stand = new THREE.Mesh(
          new THREE.CylinderGeometry(displayWidth * 0.2, displayWidth * 0.26, CUBE_SIZE * 0.6, 32),
          new THREE.MeshStandardMaterial({ color: palette.accentBlue, metalness: 0.3, roughness: 0.35 })
        );
        stand.position.set(0, -displayHeight / 2 - CUBE_SIZE * 0.45, -frameDepth * 0.35);
        kittyGroup.add(stand);

        const accentRing = new THREE.Mesh(
          new THREE.TorusGeometry(displayWidth * 0.32, CUBE_SIZE * 0.05, 24, 48),
          new THREE.MeshStandardMaterial({ color: '#fcd0e0', metalness: 0.12, roughness: 0.3 })
        );
        accentRing.rotation.x = Math.PI / 2;
        accentRing.position.set(0, -displayHeight / 2 - CUBE_SIZE * 0.2, frameDepth * 0.1);
        kittyGroup.add(accentRing);

        const frame = new THREE.Mesh(
          new THREE.BoxGeometry(displayWidth * 1.08, displayHeight * 1.12, frameDepth),
          new THREE.MeshStandardMaterial({ color: palette.warmWhite, metalness: 0.25, roughness: 0.35 })
        );
        frame.position.set(0, 0, -frameDepth * 0.4);
        kittyGroup.add(frame);

        const inset = new THREE.Mesh(
          new THREE.BoxGeometry(displayWidth * 1.02, displayHeight * 1.06, frameDepth * 0.6),
          new THREE.MeshStandardMaterial({ color: '#ffd4e1', metalness: 0.12, roughness: 0.4 })
        );
        inset.position.set(0, 0, -frameDepth * 0.15);
        kittyGroup.add(inset);

        const artPanel = new THREE.Mesh(
          new THREE.PlaneGeometry(displayWidth, displayHeight),
          new THREE.MeshStandardMaterial({
            map: kittyTexture,
            transparent: true,
            side: THREE.DoubleSide,
            roughness: 0.18,
            metalness: 0.05,
          })
        );
        artPanel.position.set(0, 0, frameDepth * 0.35);
        kittyGroup.add(artPanel);

        const acrylic = new THREE.Mesh(
          new THREE.PlaneGeometry(displayWidth, displayHeight),
          new THREE.MeshPhysicalMaterial({
            transparent: true,
            opacity: 0.35,
            roughness: 0.05,
            transmission: 0.65,
            thickness: 0.01,
          })
        );
        acrylic.position.set(0, 0, frameDepth * 0.4);
        kittyGroup.add(acrylic);

        const spotlight = new THREE.SpotLight(0xff9ac5, 0.8, CUBE_SIZE * 6, Math.PI / 6, 0.3);
        spotlight.position.set(0, displayHeight * 0.6, frameDepth * 2);
        spotlight.target.position.set(0, 0, 0);
        kittyGroup.add(spotlight);
        kittyGroup.add(spotlight.target);

        kittyGroup.rotation.y = THREE.MathUtils.degToRad(-6);
      }

      function buildDecor(width, height, date) {
        decorGroup.clear();
        const paddingX = CUBE_SIZE * 0.9;
        const paddingY = CUBE_SIZE * 1.4;
        const baseDepth = DECOR_BASE_DEPTH;
        const frontFace = TILE_DEPTH / 2;
        const alignedPanelZ = frontFace - TILE_DEPTH / 2 + 0.02;
        const baseWidth = width + paddingX * 2;
        const baseHeight = height + paddingY;

        const topCapWidth = width + CUBE_SIZE - GAP;
        const topCapMaterial = new THREE.MeshStandardMaterial({ color: palette.baseRed, roughness: 0.4 });
        const topCap = new THREE.Mesh(
          new THREE.BoxGeometry(topCapWidth, CUBE_SIZE * 0.55, TILE_DEPTH),
          topCapMaterial
        );
        topCap.position.y = baseHeight / 2 + CUBE_SIZE * 0.3;
        topCap.position.x = -CUBE_SIZE / 2;
        topCap.castShadow = true;
        topCap.receiveShadow = true;
        decorGroup.add(topCap);

        const studGeometry = new THREE.CylinderGeometry(
          CUBE_SIZE * 0.27,
          CUBE_SIZE * 0.27,
          CUBE_SIZE * 0.28,
          32
        );
        const studMaterial = new THREE.MeshStandardMaterial({
          color: palette.studRed,
          roughness: 0.25,
          metalness: 0.1,
        });
        const studRows = 2;
        const studCols = 4;
        const studSpacing = CUBE_SIZE * 0.95;
        const studStartX = -baseWidth / 2 + CUBE_SIZE * 0.9;
        for (let r = 0; r < studRows; r += 1) {
          for (let c = 0; c < studCols; c += 1) {
            const stud = new THREE.Mesh(studGeometry, studMaterial);
            stud.position.set(
              studStartX + c * studSpacing,
              baseHeight / 2 + CUBE_SIZE * 0.6,
              -CUBE_SIZE * 0.25 + r * CUBE_SIZE * 0.55
            );
            stud.castShadow = true;
            stud.receiveShadow = true;
            decorGroup.add(stud);
          }
        }
        const studRightEdge = studStartX + (studCols - 1) * studSpacing;

        const digitalClockMesh = createDigitalClockMesh();
        const tentativeClockX =
          studRightEdge + DIGITAL_CLOCK_WIDTH / 2 + CUBE_SIZE * 0.35;
        const maxClockX = topCapWidth / 2 - DIGITAL_CLOCK_WIDTH / 2 - CUBE_SIZE * 0.15;
        const clockX = Math.min(tentativeClockX, maxClockX);
        const topCapTop = topCap.position.y + (CUBE_SIZE * 0.55) / 2;
        const clockY = topCapTop + DIGITAL_CLOCK_HEIGHT / 2 + CUBE_SIZE * 0.05;
        const clockZ = frontFace - DIGITAL_CLOCK_DEPTH / 2 - TILE_DEPTH * 0.1;
        digitalClockMesh.position.set(clockX, clockY, clockZ);
        decorGroup.add(digitalClockMesh);

        const auraRadius = topCapWidth * 0.42;
        const floatingAura = createFloatingAuraParticles(auraRadius);
        const auraX = -topCapWidth / 2 + topCapWidth * 0.5;
        const auraY = topCapTop + CUBE_SIZE * 0.8;
        const auraZ = clockZ + CUBE_SIZE * 0.25;
        floatingAura.position.set(auraX, auraY, auraZ);
        decorGroup.add(floatingAura);
        floatingAuraState.group = floatingAura;
        floatingAuraState.radius = auraRadius;

        auroraPanels.length = 0;
        const gradientTexture = createGradientPlane();
        const panelGeometry = new THREE.PlaneGeometry(GRADIENT_PANEL_WIDTH, GRADIENT_PANEL_HEIGHT);
        const createPanelMesh = (sideIndex) => {
          const material = new THREE.MeshBasicMaterial({
            map: gradientTexture,
            transparent: true,
            opacity: 0.55,
            side: THREE.DoubleSide,
            depthWrite: false,
          });
          return new THREE.Mesh(panelGeometry, material);
        };
        const panelY = topCapTop + CUBE_SIZE * 0.35;
        const panelZ = frontFace - TILE_DEPTH * 0.45;
        const panelXOffset = topCapWidth / 2 + GRADIENT_PANEL_WIDTH * 0.3;
        const leftPanel = createPanelMesh(0);
        leftPanel.position.set(-panelXOffset, panelY, panelZ);
        leftPanel.rotation.y = THREE.MathUtils.degToRad(12);
        leftPanel.userData.baseY = panelY;
        decorGroup.add(leftPanel);
        auroraPanels.push(leftPanel);
        const rightPanel = createPanelMesh(1);
        rightPanel.position.set(panelXOffset, panelY, panelZ);
        rightPanel.rotation.y = THREE.MathUtils.degToRad(-12);
        rightPanel.userData.baseY = panelY;
        decorGroup.add(rightPanel);
        auroraPanels.push(rightPanel);

        const leftColumnGroup = new THREE.Group();
        decorGroup.add(leftColumnGroup);
        const redMaterial = new THREE.MeshStandardMaterial({
          color: palette.baseRed,
          roughness: 0.35,
          metalness: 0.08,
        });
        const appleTexture = createLeftColumnAppleTexture();
        const appleMaterial = new THREE.MeshStandardMaterial({
          map: appleTexture,
          roughness: 0.35,
          metalness: 0.08,
        });
        const topRedCube = new THREE.Mesh(baseGeometry, redMaterial);
        topRedCube.castShadow = true;
        topRedCube.receiveShadow = true;
        leftColumnGroup.add(topRedCube);
        const leftColumnDayCubes = [];
        for (let row = 0; row < WEEKS_VISIBLE; row += 1) {
          const material = row % 2 === 0 ? appleMaterial : redMaterial;
          const cube = new THREE.Mesh(baseGeometry, material);
          cube.castShadow = true;
          cube.receiveShadow = true;
          leftColumnGroup.add(cube);
          leftColumnDayCubes.push(cube);
        }

        const bottomTexture =
          createBottomPanelTexture(BOTTOM_PANEL_HEIGHT / BOTTOM_PANEL_BASE_HEIGHT);
        const bottomPanelDepth = TILE_DEPTH;
        const bottomCapWidth = topCapWidth;
        const bottomPanel = new THREE.Mesh(
          new THREE.BoxGeometry(bottomCapWidth, BOTTOM_PANEL_HEIGHT, bottomPanelDepth),
          new THREE.MeshStandardMaterial({
            map: bottomTexture,
            roughness: 0.35,
            metalness: 0.05,
          })
        );
        bottomPanel.position.set(-CUBE_SIZE / 2, -baseHeight / 2 + CUBE_SIZE * 0.9, alignedPanelZ);
        bottomPanel.castShadow = true;
        bottomPanel.receiveShadow = true;
        decorGroup.add(bottomPanel);

        const flipTexture = createFlipCardTexture(date);
        const flipMaterial = new THREE.MeshBasicMaterial({ map: flipTexture, side: THREE.DoubleSide });
        const flipCard = new THREE.Mesh(new THREE.PlaneGeometry(CUBE_SIZE * 1.6, CUBE_SIZE * 2.2), flipMaterial);
        const topBarTop = baseHeight / 2 + CUBE_SIZE * 0.3 + CUBE_SIZE * 0.55 * 0.5 + CUBE_SIZE * 0.25;
        const topCapLeft = -topCapWidth / 2;
        const topCapRight = topCapWidth / 2;
        const targetX = topCapLeft + (topCapRight - topCapLeft) * 0.7;
        const flipCardVerticalOffset = CUBE_SIZE * 0.9;
        flipCard.position.set(targetX, topBarTop + flipCardVerticalOffset, 0.25);
        flipCard.rotation.y = Math.PI * -0.04;
        decorGroup.add(flipCard);

        const kittyGroup = new THREE.Group();
        const kittyTargetX = topCapLeft + (topCapRight - topCapLeft) * 0.9;
        kittyGroup.position.set(kittyTargetX, topBarTop + CUBE_SIZE * 0.3, -CUBE_SIZE * 0.35);
        if (kittyTexture && kittyTexture.image) {
          addHiDefKitty(kittyGroup);
        } else {
          addClassicKitty(kittyGroup);
        }

        kittyGroup.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        decorGroup.add(kittyGroup);

        updateChronoPortalLayout(date, {
          baseWidth,
          baseHeight,
          baseDepth,
        });

        ground.position.y = -baseHeight / 2 - CUBE_SIZE * 0.15;

        return {
          frontFace,
          width,
          height,
          baseWidth,
          baseHeight,
          baseDepth,
          leftColumnTopCube: topRedCube,
          leftColumnDayCubes,
          bottomPanel,
          bottomPanelHeight: BOTTOM_PANEL_HEIGHT,
        };
      }

      function getCalendarCells(baseDate = new Date()) {
        const today = new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate());
        const firstOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        const startOffset = firstOfMonth.getDay();
        const gridStart = new Date(firstOfMonth);
        gridStart.setDate(firstOfMonth.getDate() - startOffset);

        monthLabel.textContent = today.toLocaleString('default', {
          month: 'long',
          year: 'numeric',
        });

        const cells = [];
        for (let i = 0; i < DAYS_PER_WEEK * WEEKS_VISIBLE; i += 1) {
          const date = new Date(gridStart);
          date.setDate(gridStart.getDate() + i);
          cells.push({
            date,
            inMonth: date.getMonth() === today.getMonth(),
            isToday: date.getTime() === today.getTime(),
            weekend: date.getDay() === 0 || date.getDay() === 6,
          });
        }
        return cells;
      }

      function createCalendar(baseDate = new Date()) {
        calendarDate = baseDate;
        calendarGroup.clear();
        weekdayGroup.clear();

        const cells = getCalendarCells(baseDate);
        const totalWidth = DAYS_PER_WEEK * (CUBE_SIZE + GAP);
        const totalHeight = WEEKS_VISIBLE * (DAY_HEIGHT + GAP);

        if (!layoutState || layoutState.width !== totalWidth || layoutState.height !== totalHeight) {
          layoutState = buildDecor(totalWidth, totalHeight, baseDate);
        }

        const frontFace = layoutState.frontFace;
        calendarGroup.position.z = frontFace - TILE_DEPTH / 2 + 0.02;
        const weekdayGroupZ = frontFace - TILE_DEPTH / 2 + 0.04;
        weekdayGroup.position.z = weekdayGroupZ;
        const startX = -totalWidth / 2 + (CUBE_SIZE + GAP) / 2;
        const startY = totalHeight / 2 - (DAY_HEIGHT + GAP) / 2;
        const weekdayY = startY + DAY_HEIGHT / 2 + GAP + WEEKDAY_CUBE_HEIGHT / 2;
        const topCapHeight = CUBE_SIZE * 0.55;
        const topCapYOffset = CUBE_SIZE * 0.3;
        const topBlockBottom = layoutState.baseHeight / 2 + topCapYOffset - topCapHeight / 2;
        const weekdayRowTarget = topBlockBottom - GAP - WEEKDAY_CUBE_HEIGHT / 2;
        const gridTopTarget = weekdayRowTarget - (DAY_HEIGHT + GAP);
        calendarGroup.position.y = gridTopTarget - startY;
        weekdayGroup.position.y = weekdayRowTarget - weekdayY;
        const gridBottomTarget = gridTopTarget - (WEEKS_VISIBLE - 1) * (DAY_HEIGHT + GAP);
        if (layoutState.bottomPanel) {
          const bottomCubeBottom = gridBottomTarget - DAY_HEIGHT / 2;
          layoutState.bottomPanel.position.y = bottomCubeBottom - layoutState.bottomPanelHeight / 2 + GAP * 0.5;
        }
        const columnZ = calendarGroup.position.z;
        const leftColumnX = startX - CUBE_SIZE;
        const calendarYOffset = calendarGroup.position.y;
        if (layoutState.leftColumnDayCubes) {
          layoutState.leftColumnDayCubes.forEach((cube, row) => {
            const y = startY - row * (DAY_HEIGHT + GAP);
            cube.position.set(leftColumnX, calendarYOffset + y, columnZ);
          });
        }
        if (layoutState.leftColumnTopCube) {
          const weekdayTop = weekdayGroup.position.y + weekdayY + WEEKDAY_CUBE_HEIGHT / 2;
          layoutState.leftColumnTopCube.position.set(leftColumnX, weekdayTop - DAY_HEIGHT / 2, columnZ);
        }
        const eventTextures = eventSpecs.map((spec) => createEventBrickTexture({ ...spec, icon: null }));
        const iconTextures = iconSpecs.map((spec) => createEventBrickTexture({ label: '', accent: spec.accent, icon: spec.icon }));
        const lastActiveIndex = cells.reduce((acc, cell, idx) => (cell.inMonth ? idx : acc), -1);
        const extraSlots = new Map();
        let nextIdx = lastActiveIndex + 1;
        eventTextures.forEach((texture) => {
          if (nextIdx < cells.length) {
            extraSlots.set(nextIdx, texture);
            nextIdx += 1;
          }
        });
        iconTextures.forEach((texture) => {
          if (nextIdx < cells.length) {
            extraSlots.set(nextIdx, texture);
            nextIdx += 1;
          }
        });

        cells.forEach((cell, idx) => {
          const col = idx % DAYS_PER_WEEK;
          const row = Math.floor(idx / DAYS_PER_WEEK);
          const extraTexture = extraSlots.get(idx);
          if (extraTexture) {
            const material = new THREE.MeshStandardMaterial({
              map: extraTexture,
              color: 0xffffff,
              metalness: 0.05,
              roughness: 0.6,
            });

            const cube = new THREE.Mesh(baseGeometry, material);
            cube.position.set(
              startX + col * (CUBE_SIZE + GAP),
              startY - row * (DAY_HEIGHT + GAP),
              0
            );
            cube.castShadow = true;
            cube.receiveShadow = true;
            calendarGroup.add(cube);
            return;
          }

          if (!cell.inMonth) {
            const cube = new THREE.Mesh(baseGeometry, emptyDayMaterial);
            cube.position.set(
              startX + col * (CUBE_SIZE + GAP),
              startY - row * (DAY_HEIGHT + GAP),
              0
            );
            cube.castShadow = true;
            cube.receiveShadow = true;
            calendarGroup.add(cube);
            return;
          }

          const texture = createDayTexture({
            label: cell.date.getDate().toString(),
            active: cell.inMonth,
            highlight: cell.isToday,
            weekend: cell.weekend,
          });

          const material = new THREE.MeshStandardMaterial({
            map: texture,
            color: 0xffffff,
            metalness: 0.05,
            roughness: 0.6,
          });

          const cube = new THREE.Mesh(baseGeometry, material);
          cube.position.set(
            startX + col * (CUBE_SIZE + GAP),
            startY - row * (DAY_HEIGHT + GAP),
            0
          );
          cube.castShadow = true;
          cube.receiveShadow = true;
          calendarGroup.add(cube);
        });

        // Weekday labels sit slightly above cubes
        weekdays.forEach((day, idx) => {
          const spriteMap = createWeekdayTexture(day, idx === 0 || idx === 6);
          const material = new THREE.MeshStandardMaterial({
            map: spriteMap,
            roughness: 0.45,
            metalness: 0.05,
          });
          const cube = new THREE.Mesh(WEEKDAY_CUBE_GEOMETRY, material);
          cube.position.set(
            startX + idx * (CUBE_SIZE + GAP),
            weekdayY,
            0
          );
          cube.castShadow = true;
          cube.receiveShadow = true;
          weekdayGroup.add(cube);
        });
      }

      createCalendar(calendarDate);

      window.addEventListener('resize', onResize);
      container.addEventListener('pointermove', onPointerMove);
      container.addEventListener('pointerleave', resetPointerParallax);

      function onResize() {
        const { clientWidth, clientHeight } = container;
        camera.aspect = clientWidth / clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(clientWidth, clientHeight);
      }

      function onPointerMove(event) {
        const rect = container.getBoundingClientRect();
        const normX = ((event.clientX - rect.left) / rect.width - 0.5) * 2;
        const normY = ((event.clientY - rect.top) / rect.height - 0.5) * -2;
        chronoPortalState.pointer.set(normX, normY);
      }

      function resetPointerParallax() {
        chronoPortalState.pointer.set(0, 0);
      }

      function animate() {
        requestAnimationFrame(animate);
        calendarRig.rotation.y += 0.0005;
        calendarRig.rotation.x = THREE.MathUtils.lerp(calendarRig.rotation.x, 0.1, 0.02);
        if (digitalClockState.haloPivot) {
          const time = performance.now() * 0.001;
          digitalClockState.haloPivot.rotation.y += 0.015;
          digitalClockState.haloPivot.rotation.z = Math.sin(time * 0.75) * 0.18;
        }
        if (floatingAuraState.group) {
          const time = performance.now() * 0.001;
          floatingAuraState.group.rotation.y = time * 0.4;
          floatingAuraState.group.children.forEach((particle, index) => {
            const offset = particle.userData.offset || 0;
            particle.position.y =
              particle.userData.baseY + Math.sin(time * 1.2 + offset + index * 0.25) * 0.08;
            particle.position.z =
              Math.sin(time * 0.6 + index * 0.3) * floatingAuraState.radius * 0.35;
          });
        }
        if (auroraPanels.length) {
          const t = performance.now() * 0.0007;
          auroraPanels.forEach((panel, index) => {
            const baseY = panel.userData.baseY || panel.position.y;
            panel.position.y = baseY + Math.sin(t + index * 0.6) * 0.12;
            panel.rotation.y = THREE.MathUtils.degToRad(12) * (index === 0 ? 1 : -1) + Math.sin(t * 0.8) * 0.1;
            panel.material.opacity = 0.45 + Math.sin(t * 1.1 + index) * 0.08;
          });
        }
        if (chronoPortalState.group && chronoPortalState.uniforms) {
          const portalTime = performance.now() * 0.001;
          chronoPortalState.uniforms.uTime.value = portalTime;
          chronoPortalState.parallax.lerp(chronoPortalState.pointer, 0.08);
          chronoPortalState.uniforms.uParallax.value.copy(chronoPortalState.parallax);
          chronoPortalState.tempPosition.copy(chronoPortalState.anchor);
          chronoPortalState.tempPosition.x += chronoPortalState.parallax.x * CUBE_SIZE * 0.5;
          chronoPortalState.tempPosition.y += chronoPortalState.parallax.y * CUBE_SIZE * 0.6;
          chronoPortalState.group.position.lerp(chronoPortalState.tempPosition, 0.08);
          chronoPortalState.group.rotation.y = THREE.MathUtils.lerp(
            chronoPortalState.group.rotation.y,
            THREE.MathUtils.degToRad(-4) + chronoPortalState.parallax.x * 0.2,
            0.08
          );
          chronoPortalState.group.rotation.x = THREE.MathUtils.lerp(
            chronoPortalState.group.rotation.x,
            THREE.MathUtils.degToRad(-6) + chronoPortalState.parallax.y * 0.12,
            0.08
          );
          chronoPortalState.rings.forEach((ring, index) => {
            ring.rotation.z += 0.0035 * (ring.userData.spin || 1);
            ring.rotation.x = Math.PI / 2.4 + Math.sin(portalTime * 0.4 + index * 0.6) * 0.08;
          });
          chronoPortalState.sparks.forEach((spark) => {
            const data = spark.userData;
            const angle = portalTime * data.speed + data.offset;
            spark.position.set(
              Math.cos(angle) * data.radius,
              Math.sin(portalTime * 1.6 + data.offset) * data.lift,
              Math.sin(angle) * data.radius * 0.45
            );
            const scale = 0.55 + Math.sin(portalTime * 2.2 + data.offset) * 0.25;
            spark.scale.setScalar(scale);
            spark.material.opacity = 0.35 + (Math.sin(portalTime * 3.0 + data.offset) + 1) * 0.3;
          });
          if (chronoPortalState.pulseLight) {
            chronoPortalState.pulseLight.intensity = 1.4 + Math.sin(portalTime * 2.6) * 0.7;
          }
          if (chronoPortalState.hazeMesh) {
            chronoPortalState.hazeMesh.rotation.z += 0.0008;
          }
        }
        controls.update();
        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
